<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>ÏßÄÎ¢∞Ï∞æÍ∏∞ (Minesweeper)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/variable/pretendardvariable-dynamic-subset.css');
  body {
    margin: 0; padding: 0; min-height: 100vh;
    font-family: 'Pretendard Variable', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    background: linear-gradient(135deg, #f0f6ff 70%, #fffbe6 100%);
    color: #1a2a4f;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  h1 {
    margin-top: 32px;
    font-weight: 700;
    font-size: 2.4rem;
    color: #3259db;
    letter-spacing: 3px;
    user-select: none;
  }
  .controls {
    margin-top: 12px;
    display: flex;
    gap: 12px;
    justify-content: center;
  }
  button.level-btn {
    background: #dbefff;
    border: none;
    border-radius: 8px;
    padding: 10px 18px;
    font-weight: 700;
    color: #3168de;
    cursor: pointer;
    font-size: 1.05rem;
    transition: background-color 0.3s;
  }
  button.level-btn.selected {
    background: #ffd859;
    color: #895e00;
  }
  #resetBtn {
    margin: 14px auto 0 auto;
    background: #4b8aff;
    color: #fff;
    border: none;
    border-radius: 8px;
    padding: 10px 26px;
    font-weight: 700;
    cursor: pointer;
    font-size: 1.15rem;
    box-shadow: 0 3px 10px #3a6ed9aa;
    transition: background-color 0.25s;
    display: block;
  }
  #resetBtn:hover {
    background-color: #366fcc;
  }
  .status-bar {
    margin-top: 18px;
    width: 100%;
    max-width: 600px;
    display: flex;
    justify-content: space-between;
    font-weight: 700;
    font-size: 1.1rem;
    padding: 6px 16px;
    background: #ffffffdd;
    border-radius: 10px;
    box-shadow: 0 3px 15px #8db7f732;
    user-select: none;
  }
  #board {
    margin-top: 22px;
    background: #e7f1fa;
    border-radius: 16px;
    padding: 16px 16px 12px 16px;
    border: 3px solid #9fd5fc;
    box-shadow: 0 3px 20px #c3e0ff77;
  }
  .row {
    display: flex;
  }
  .cell {
    width: 34px;
    height: 34px;
    margin: 3px;
    background: #fafdff;
    border-radius: 8px;
    box-shadow: 0 1.5px 8px #b6d5fa88 inset;
    border: 1.6px solid #bdd1ec;
    text-align: center;
    font-weight: 700;
    font-size: 1.15rem;
    line-height: 34px;
    cursor: pointer;
    user-select: none;
    color: #244a8d;
    transition: background-color 0.15s, color 0.15s, box-shadow 0.15s;
  }
  .cell.revealed {
    background: #fffbe8;
    border-color: #d0bb6a;
    box-shadow: 0 2.5px 13px #ffeaa022;
    color: #3055a7;
    cursor: default;
  }
  .cell.mine.revealed {
    background: #f36b3f;
    color: white;
    border-color: #ca4421;
    box-shadow: 0 0 14px #f57e5faa;
    font-size: 1.2rem;
  }
  .cell.flag {
    background: #ffe18e;
    color: #695100;
    border-color: #e0bc46;
    box-shadow: 0 0 12px #ffdb7cbb;
    font-size: 1.3rem;
  }
  .best-record {
    margin-left: 8px;
    font-size: 0.95rem;
    color: #bb9400;
  }
  @media (max-width: 600px) {
    .cell {
      width: 26px;
      height: 26px;
      line-height: 26px;
      font-size: 0.9rem;
      margin: 2px;
    }
    .status-bar {
      font-size: 1rem;
      padding: 5px 12px;
    }
  }
</style>
</head>
<body>
  <h1>üí£ ÏßÄÎ¢∞Ï∞æÍ∏∞</h1>
  <div class="controls">
    <button class="level-btn selected" data-rows="9" data-cols="9" data-mines="10">Ï¥àÍ∏â (9√ó9, 10)</button>
    <button class="level-btn" data-rows="16" data-cols="16" data-mines="40">Ï§ëÍ∏â (16√ó16, 40)</button>
    <button class="level-btn" data-rows="16" data-cols="30" data-mines="99">Í≥†Í∏â (16√ó30, 99)</button>
  </div>
  <button id="resetBtn">ÏÉà Í≤åÏûÑ üîÑ</button>
  <div class="status-bar">
    <div>üö© ÎÇ®ÏùÄ ÏßÄÎ¢∞: <span id="flagsLeft">0</span></div>
    <div>‚è±Ô∏è ÏãúÍ∞Ñ: <span id="timerVal">0</span>Ï¥à<span id="bestRecord" class="best-record"></span></div>
  </div>
  <div id="board"></div>

<script>
  let rows = 9, cols = 9, mines = 10;
  let board = [], revealed = [], flagged = [];
  let gameOver = false;
  let cellsRevealed = 0;
  let flagsLeft = 0;
  let timer = 0;
  let timerId = null;
  let started = false;
  let firstClick = true;
  let levelKey = 'easy';
  let bestRecords = { easy: null, normal: null, hard: null };

  const boardDiv = document.getElementById('board');
  const flagsLeftSpan = document.getElementById('flagsLeft');
  const timerValSpan = document.getElementById('timerVal');
  const bestRecordSpan = document.getElementById('bestRecord');
  const resetBtn = document.getElementById('resetBtn');

  const LEVELS = [
    {name:'Ï¥àÍ∏â', rows:9, cols:9, mines:10, key:'easy'},
    {name:'Ï§ëÍ∏â', rows:16, cols:16, mines:40, key:'normal'},
    {name:'Í≥†Í∏â', rows:16, cols:30, mines:99, key:'hard'}
  ];

  function loadRecords() {
    try {
      const data = JSON.parse(localStorage.getItem('minesBest'));
      if(data) bestRecords = {...bestRecords, ...data};
    } catch {}
  }
  function saveRecords() {
    localStorage.setItem('minesBest', JSON.stringify(bestRecords));
  }
  function updateBestRecordUI() {
    const rec = bestRecords[levelKey];
    bestRecordSpan.textContent = rec ? ` | ÏµúÍ≥†Í∏∞Î°ù: ${rec}Ï¥à` : '';
  }

  document.querySelectorAll('.level-btn').forEach(btn=>{
    btn.addEventListener('click', () => {
      document.querySelectorAll('.level-btn').forEach(b => b.classList.remove('selected'));
      btn.classList.add('selected');
      rows = +btn.dataset.rows;
      cols = +btn.dataset.cols;
      mines = +btn.dataset.mines;
      levelKey = LEVELS.find(l => l.rows === rows && l.cols === cols && l.mines === mines).key;
      resetGame();
    });
  });

  resetBtn.addEventListener('click', () => {
    resetGame();
  });

  function resetGame() {
    firstClick = true;
    started = false;
    gameOver = false;
    timer = 0;
    cellsRevealed = 0;
    flagsLeft = mines;
    flagsLeftSpan.textContent = flagsLeft;
    timerValSpan.textContent = timer;
    clearInterval(timerId);
    timerId = null;

    board = Array.from({length:rows}, () => Array(cols).fill(0));
    revealed = Array.from({length:rows}, () => Array(cols).fill(false));
    flagged = Array.from({length:rows}, () => Array(cols).fill(false));

    drawBoard();
    updateBestRecordUI();
  }

  function placeMines(excludeRow, excludeCol) {
    let placed = 0;
    while (placed < mines) {
      const r = Math.floor(Math.random() * rows);
      const c = Math.floor(Math.random() * cols);
      if (board[r][c] === 9) continue;
      if (Math.abs(r - excludeRow) <= 1 && Math.abs(c - excludeCol) <= 1) continue;
      board[r][c] = 9;
      placed++;
    }
  }

  function calculateNumbers() {
    for(let r=0; r<rows; r++) {
      for(let c=0; c<cols; c++) {
        if(board[r][c] === 9) continue;
        let count = 0;
        for(let dr=-1; dr<=1; dr++) {
          for(let dc=-1; dc<=1; dc++) {
            let nr = r+dr, nc = c+dc;
            if(nr >= 0 && nr < rows && nc >= 0 && nc < cols && board[nr][nc] === 9) count++;
          }
        }
        board[r][c] = count;
      }
    }
  }

  function startTimer() {
    if(started) return;
    started = true;
    timerId = setInterval(() => {
      timer++;
      timerValSpan.textContent = timer;
    }, 1000);
  }

  function stopTimer() {
    clearInterval(timerId);
    timerId = null;
  }

  function drawBoard() {
    let html = '';
    for(let r=0; r<rows; r++) {
      html += '<div class="row">';
      for(let c=0; c<cols; c++) {
        let cls = 'cell';
        let text = '';
        if(revealed[r][c]) {
          cls += ' revealed';
          if(board[r][c] === 9) {
            cls += ' mine';
            text = 'üí£';
          } else if(board[r][c] > 0) {
            text = board[r][c];
          }
        } else if(flagged[r][c]) {
          cls += ' flag';
          text = 'üö©';
        }
        html += `<div class="${cls}" data-r="${r}" data-c="${c}">${text}</div>`;
      }
      html += '</div>';
    }
    boardDiv.innerHTML = html;

    document.querySelectorAll('.cell').forEach(cell => {
      const r = +cell.dataset.r;
      const c = +cell.dataset.c;

      cell.oncontextmenu = e => e.preventDefault();

      cell.onmousedown = e => {
        if(gameOver || revealed[r][c]) return;

        if(e.button === 2) {
          if(flagged[r][c]) {
            flagged[r][c] = false;
            flagsLeft++;
          } else if(flagsLeft > 0) {
            flagged[r][c] = true;
            flagsLeft--;
          }
          flagsLeftSpan.textContent = flagsLeft;
          drawBoard();
        } else if(e.button === 0) {
          if(firstClick) {
            firstClick = false;
            placeMines(r, c);
            calculateNumbers();
            openSafeArea(r, c);
            startTimer();
          } else {
            openCell(r, c);
          }
        }
      };

      cell.onclick = () => {
        if(gameOver) return;
        if(!revealed[r][c]) return;
        autoOpenAround(r, c);
      };

      let timerTouch;
      cell.ontouchstart = () => {
        timerTouch = setTimeout(() => {
          if(!revealed[r][c]) {
            flagged[r][c] = !flagged[r][c];
            flagsLeft += flagged[r][c] ? -1 : 1;
            flagsLeftSpan.textContent = flagsLeft;
            drawBoard();
          }
        }, 400);
      };
      cell.ontouchend = () => clearTimeout(timerTouch);
    });
  }

  function openSafeArea(r, c) {
    const queue = [];
    const visited = Array.from({length:rows}, () => Array(cols).fill(false));
    queue.push([r,c]);
    visited[r][c] = true;

    while(queue.length) {
      const [cr, cc] = queue.shift();
      if(!revealed[cr][cc] && !flagged[cr][cc]) {
        revealed[cr][cc] = true;
        cellsRevealed++;
      }
      if(board[cr][cc] === 0) {
        for(let dr = -1; dr <= 1; dr++) {
          for(let dc = -1; dc <= 1; dc++) {
            let nr = cr + dr, nc = cc + dc;
            if(nr >= 0 && nr < rows && nc >= 0 && nc < cols && !visited[nr][nc] && board[nr][nc] !== 9) {
              queue.push([nr,nc]);
              visited[nr][nc] = true;
            }
          }
        }
      }
    }
    drawBoard();
  }

  function openCell(r, c) {
    if(revealed[r][c] || flagged[r][c] || gameOver) return;

    revealed[r][c] = true;
    cellsRevealed++;

    if(board[r][c] === 9) {
      gameOver = true;
      revealAll();
      stopTimer();
      setTimeout(() => alert('üí• Í≤åÏûÑ Ïò§Î≤Ñ! ÏßÄÎ¢∞Î•º Î∞üÏïòÏäµÎãàÎã§!'), 150);
      return;
    }

    if(board[r][c] === 0) {
      for(let dr = -1; dr <= 1; dr++) {
        for(let dc = -1; dc <= 1; dc++) {
          let nr = r + dr, nc = c + dc;
          if(nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
            if(!revealed[nr][nc]) openCell(nr, nc);
          }
        }
      }
    }

    if(cellsRevealed === rows * cols - mines) {
      gameOver = true;
      revealAll();
      stopTimer();
      setTimeout(() => {
        if(!bestRecords[levelKey] || timer < bestRecords[levelKey]) {
          bestRecords[levelKey] = timer;
          saveRecords();
          updateBestRecordUI();
          alert(`üéâ ÏäπÎ¶¨! Í∏∞Î°ù Í∞±Ïã†! ${timer}Ï¥à`);
        } else {
          alert('üéâ ÏäπÎ¶¨! Î™®Îì† ÏßÄÎ¢∞Î•º Ï∞æÏïòÏäµÎãàÎã§!');
        }
      }, 150);
    }
    drawBoard();
  }

  function revealAll() {
    for(let r=0; r<rows; r++) {
      for(let c=0; c<cols; c++) {
        revealed[r][c] = true;
      }
    }
    drawBoard();
  }

  function autoOpenAround(r, c) {
    if(!revealed[r][c]) return;
    if(board[r][c] === 0 || board[r][c] === 9) return;

    const number = board[r][c];
    let flagCount = 0;
    let unopened = [];

    for(let dr=-1; dr<=1; dr++) {
      for(let dc=-1; dc<=1; dc++) {
        if(dr === 0 && dc === 0) continue;
        const nr = r+dr, nc = c+dc;
        if(nr < 0 || nr >= rows || nc < 0 || nc >= cols) continue;

        if(flagged[nr][nc]) flagCount++;
        else if(!revealed[nr][nc]) unopened.push([nr,nc]);
      }
    }

    if(flagCount === number) {
      for(const [nr, nc] of unopened) {
        openCell(nr, nc);
      }
    }
  }

  loadRecords();
  resetGame();
</script>
</body>
</html>
